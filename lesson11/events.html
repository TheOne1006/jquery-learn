<!DOCTYPE html>
<html>
<head>
  <title>jQuery源码学习 - 第十一部分:line 4300，</title>
  <meta content="text/html;charset=utf-8" http-equiv="content-type">
  <link rel="stylesheet" type="text/css" href="../bootcss/css/bootstrap.css">
  <script type="text/javascript" src='../jquery.js'></script>
  <script>
    $.extend({
      log: function(){
        var messages = Array.prototype.slice.call(arguments, 0);
        // 控制台输出,上下文必须时 console
        console.log.apply( console, ['$log:'].concat(messages) );
      },
      log2: function() {
        console.log.apply( console, arguments);
      }
    });
  </script>
</head>
<body>
  <div class="container">
    <div class="page-header">
      <h1>Events <small>事件系统</small> </h1>
      <ol>
        <li>兼容浏览器</li>
        <li>统一管理</li>
        <li>支持手动触发</li>
        <li>自定义事件</li>
        <li>命名空间支持 更灵活和安全</li>
        <li> 为什么不用extend 扩展jQuery对象</li>
      </ol>
      <div class="row">
        <div class="col-md-6">
          <fieldset>
            <legend> <small>jQuery.event 工具对象</small> </legend>
            <ul>
              <li>add():</li>
              <li>remove():</li>
              <li>trigger():</li>
              <li>dispatch(): 事件代理</li>
              <li>handlers():</li>
              <li>props:'string'</li>
              <li>fixHooks:{}</li>
              <li>keyHooks:{}</li>
              <li>mouseHooks:{}</li>
              <li>fix():</li>
              <li>special:{}</li>
              <li>simulate():</li>

              <li> 特殊 jQuery.removeEvent(): <code>调用$.fn.removeEventLister()</code></li>
            </ul>
          </fieldset>
        </div>
        <div class="col-md-6">
          <fieldset>
            <legend> <small>jQuery.Event jQuery事件对象</small></legend>
            <ul>
              <li>
                jQuery.Event 构造函数
              </li>
              <li>originalEvent</li>
              <li>type</li>
              <li>preventDefault()</li>
              <li>stopPropagation()</li>
              <li>stopImmediatePropagation()</li>
            </ul>
          </fieldset>
        </div>
        <div class="col-md-6">
          <fieldset>
            <legend> <small>$.fn.Event实例方法</small> </legend>
            <ul>
              <li>
                on(): <code> 调用 $.event.add </code>
              </li> 
              <li>
                one(): <code>调用 $.fn.on</code>
              </li>
              <li>
                off(): <code>调用 $.event.remove</code>
              </li>
              <li>trigger: <code>调用 $.event.trigger</code> </li>
              <li>
                triggerHandle: <code>调用 $.event.trigger</code>
              </li>
            </ul>
          </fieldset>
        </div>
    </div>
    <div class="row">
      <h2>方法调用链:</h2>
      <ol>
        <li> 浏览器触发事件: <code>主监听函数? -> jQuery.event.dispatch()? -> jQuery.event.fix() -> jQuery.Event()? </code></li>
        <li>绑定事件: <code> $.fn.click 等 -> $.fn.on -> jQuery.event.add() -> addEventListener/attachEvent/jQuery._data() </code></li>
      </ol>
    </div>

    <div class="pannel pannel-default">
      <div class="pannel-heding"> </div>
      <div class="pennel-body">
      <h4>
        伪代码结构
      </h4>
<pre>
//- 事件对象,低层方法,工具方法
jQuery.event = {
  
  global:{},

  add(elem, types, handler, data, selector): 绑定监听

  /**
   * types 事件类型字符串 空格分割
   * hander 1监听函数  2 自定义监听对象 ?
   * data ?
   * selector 选择器表达式,用于绑定代理事件
   */
  function ( elem, types, handler, data, selector ) {

    //- 初始化变量
    var handleObjIn, // 传入监听对象
      eventHandle,   // 主要监听函数
      tmp,
      events,        // dom 元素的 Data关联的事件缓存对象
      t,             // for 遍历计数器
      handleObj,     // 封装了事件函数的监听对象 ?
      special,       // 具体的修正对象,没有则为空
      handlers,      // 监听对象数组
      type,          // 事件类型
      namespaces,    // 命名空间？
      origType,      //
      elemData = data_priv.get(elem); //-获取data数据

      //- 过滤不可用元素
      if( !elemData ) {
        // 过滤规则同 Data.accepts
        return; 
      }

      //- hander 可以是自定义监听对象
      if ( handler.handler ) {

        //- 设置变量
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }

      //- 为监听函数分配唯一标识符 guid
      if ( !hander.guid ) {
        handler.guid = jQuery.guid++;
      }

      //- 初始化缓存对象 elemData.events
      // 用于存放当前元素关联的所有监听函数
      if ( !(events = elemData.events) ) {
        events = elemData.events = {};
      }

      //- 取出或者初始化主监听函数
      // 一个元素只分发一次主监听函数,所有类型的事件只有真正一个主监听函数绑定到元素上
      if( !(eventHandle = elemData.handle) ) {
        eventHandle = elem.handle = function(e) {

          //-? 前面判断??
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
            jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
            undefined;
        };
        // 将elem 存入主函数到 elem 属性中？
        eventHandle.elem = elem;
      }


      // 匹配获得所有非空集合
      types = ( types || "").match( core_rnotwhite ) || [""];
      t = types.length;

      while(t--) {
        /**
         * 解析事件类型和命名空间
         * rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
         * 命名空间 无层级关系 "."号分割
         */
        tmp = rtypenamespace.exec( types[t] ) || [];
        type = origType = tmp[1]; // 获取事件类型type
        namespaces = (tmp[2] || "" ).split(".").sort();

        // 必须要有 type 的存在
        if( !type ) {
          continue;
        }


        //- 尝试获取修正对象
        special = jQuery.event.special[ type ] || {};
        //- selector 存在则为代理事件
        type = ( selector ? special.delegateType : special.bindType ) || type;

        //- type 可能重新设置,再次获取对应的修正对象
        special = jQuery.event.special[ type ] || {};

        // 扩展封装成监听对象, 如过参数handler 是对象,也回扩展进来       
        handleObj = jQuery.extend({
          type: type,            // 处理后的type
          origType: origType,    // 原来的type
          data: data,            // 参数data
          handler: handler,      // 监听函数
          guid: hanler.guid,     // guid
          selector: selector,    // selector
          needContext: selecor && jQuery.expr.match.needsContext.test( selector ),
          namespace: namespaces.join(".") //重新组成命名空间


        }, handleObjIn );


// 尝试取出对应type 的监听对象数组,或者对其进行初始化
        if( !(handlers = events[type] ) ) {
------------- init handlers --------------------
          handlers = events[type] = [];
          // 位置计数器: 用于指示下个代理监听对象插入的位置
          handlers.delegateCount = 0;

          //- 尝试使用 修正对象的setup 绑定主监听函数,失败则使用默认 addEventListener , ie 则用 attachEvent
          if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
            if ( elem.addEventListener ) {
              elem.addEventListener( type, eventHandle, false );
            }
          }
------------- init handlers --------------------
        }

        // 尝试使用修正对象的方法 add,修正 guid
        if( spcial.add){
          spcial.add.call(elem, handleObj);

          if( !handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }


        // 将 handleObj 添加到 handlers 中
        if ( selector ) {
          // 代理监听对象 都考前排
          handlers.splice( handlers.delegateCount++, 0, handleObj );
        } else {
          handlers.push( handleObj );
        }

        // 记录绑定过的时间类型
        jQuery.event.global[ type ] = true;
        
      }

      // 解除参数对dom元素对引用，避免内存泄漏(ie)
      elem = null;


  }


  remove(): 移除监听

  trigeer(): 手动触发事件

  dispatch(): 分发

  handlers(): 

  props: 事件对象的公共属性

  fixHooks:{}  hook 对象

  keyHooks:{}   键盘对象的属性和修正方法
  {
    // ['char','charCode','key','keyCode'] 键盘专属属性
    props:"char charCode key keyCode".split(" ");
    filter(jquery事件对象, 原生事件): // 修正方法
    function( event, original ) {

      // 兼容 键盘事件专属属性which,尝试从 original.charCode 或者kayCode 中获取
      if( event.which == null) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
      }

      return event.which;

    }

  }

  mouseHooks:{} 针对鼠标的事件兼容
  {
    // 鼠标专属
    props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter(event, original ): // 修正方法
    function( event, original ) {
      //- 设置变量
      var eventDoc, doc, body,
        button = original.button;

      if( event.pageX == null && original.clientX != null) {
        // 没有pageX 属性,计算

        距离文档左坐标 pageX = 距离窗口左坐标 clientX + 水平滚动偏移 - 文档左边框厚度

        距离文档上坐标 pageX = 距离窗口上坐标 clientY + 垂直滚动偏移 - 文档上边框厚度
      }

      // 点击按钮修正 修正为 左 1, 中2 , 右3
      if( !event.which && button !== undefined ) {
        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
      }

      return event;
    }
  }

  fix(): 原生事件对象封装成jQuery对象,并修正不兼容

  /**
   * event 可以是 原生event, 也可以是jQuery对象
   */
  function( event ) {
    // 当前已经是 $.Eventdui对象,不需要执行封装,修正代码
    if( event[ jQuery.expando ]) {
      return event;
    }

    //- 定义变量
    var i,
      prop,
      copy,
      type = event.type,
      originalEvent = event,
      fixHook = this.fixHooks[type]; //根据type 尝试获取 修正对象

    if( !foxHook ) {
      //- 没找到修正对象,再次尝试 从mouseHooks,或者keyHooks中寻找,找到后将对象赋予 fixHooks[type]方便下次寻找
      this.fixHooks[ type ] = fixHook =
        rmouseEvent.test( type ) ? this.mouseHooks :
        rkeyEvent.test( type ) ? this.keyHooks :
        {};
    }

    //- 尝试合并 fixHook数组 和 this.prop
    copy = fixHook.props ? this.prop.concat( fixHook.props): this.props;

    //- 生成 jQuery.Event对象
    event = new jQuery.Event( originalEvent );

    // 将原事件对象 遍历赋值 给jQuery.Event
    i = copy.length;
    while( i-- ) {
      prop = copy[i];
      event[prop] = originalEvent[ prop ];
    } 

    //- support 兼容
    // 获取不到 target 属性则设置为document
    if( !event.target ) {
      event.target = document; //? 作用
    }

    if( event.target.nodeType === 3) {
      event.target = event.target.parentNode;
    }

    //- 尝试返回修正后的事件对象,或者 event;
    return fixHook.filter? fixHook.filter( event, originalEvent) : event;





  }

  special:{} 事件修正对象集

  simulate(): 模拟事件
  
}

//- 移除监听函数
jQuery.removeEvent ＝ function( elem, type, handle)

//－ jQuery事件对象 构造函数
/**
 * src: 原生事件类型/自定义事件类型/原生事件对象/jQuery事件对象
 * props: 可选的js对象,其中的属性将被设置到新建的jQuery事件对象上
 */
jQuery.Event = function( src, props) {
  //- 省略new 操作符, 修改this 由jQuery 指向 jQuery.Event
  if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
  }

  //- 原生事件 进行备份和处理
  // type 特征属性
  if( src && src.type) {
    this.orginalEvent = src; // 备份原生事件
    this.type = src.type;    // 获取type 如:'click'

    // 处理默认冒泡
    this.isDefaultPrevented = ( src.defaultPrevented ||
      src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

  } else {
    this.type = src; // 事件类型
  }

  //- 扩展自定义对象属性
  if( props ) {
    jQuery.extend(this, props);
  }

  //- 修正时间戳, ie9－ 原生事件没有 timeStamp
  // jQuery.now = function() {return (new Date()).getTime(); }
  this.timeStamp = src && src.timeStamp || jQuery.now();

  // 固定标记
  /**
   * jQuery 事件系统其他部分,通过jQuery.expando 来判断， instanceof 需要检查原型链,判断属性更加高效
   */
  this[ jQuery.expando ] = true;

}

//- jQuery.Event 原型对象
jQuery.Event.prototype = {
  
  isDefaultPrevented: returnFalse,   // 是否组阻止默认行为
  isPropagationStopped: returnFalse, // 判断是否阻止传播/获取
  isImmediatePropagationStopped: returnFalse, 

  // 阻止 原生事件对象的默认行为
  preventDefault: function() {
    var e = this.originalEvent; // 尝试获取 备份事件对象

    this.isDefaultPrevented = returnTrue;

    // 容错,没有parevetDefault 的说明是自定义事件
    if ( e && e.preventDefault ) {
      // 取消浏览器事件后的默认执行
      // ie9- e.returnValue = false;
      e.preventDefault();
    }

  },

  // 阻止 事件传播/事件捕获
  stopPropagation: function() {
    var e = this.originalEvent;

    this.isPropagationStopped = returnTrue;

    if( e && e.stopPropagation) {
      //- 取消捕获(传播)
      // ie9- e.canelBulle =true;
      e.stopPropagation();
    }
  },

  // 立即停止事件执行和事件传播
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = returnTrue;
    // stopPropagation(); 阻止 事件传播/事件捕获
    this.stopPropagation();
  }






} 


//- 初始化事件 mouseenter.... 对应低修正对象
jQuery.each({},fun)


/**
 * 扩展实例方法
 * 后续扩展遗留方法 bind, unbind, ...
 */
jQuery.fn.extend({
  
  on(): 统一的绑定方法
  /**
   * types 事件类型
   * selector 一个选择器表示字符串,设置则为开启事件代理
   * data 
   * fn 待绑定监听函数
   */
  function( types, selector, data, fn , one) {

    //- 变量
    var origFn,
      type;

    //- types 满足typeof 条件
    if( typeof types === 'object' ) {

      // 省参 selctor 
      if( typeof selector !== 'string' ) {
        data = data || selector;
        selector = undefined;
      }

      // 遍历types 集合,继续调用 on
      for ( type in types) {
        this.on( type, selector, data, types[ type ], one );
      }

      return this;
    }

    //- 根据参数类型,修正参数
    if( data == null && fn = null ) {
      // 支持类型 .on(type, fn)
      fn = selector;
      data = selector = undefined;
    } else if (fn = null) {

      if( typeof selector === "string" ) {
        // 支持参数类型 .on(type, selector, fn)
        fn = data;
        data = undefined;
      } else {
        // 支持参数类型 .on(types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }

    }

    //- 修正 fn === false
    if( fn === false) {
      fn = returnFalse;
    } else if( !fn ) {
      //- 如果 fn 是其他false值 直接输出this,
      return this;
    }

    /**
     * 重新创建 fn,只执行一次 原fn 之后 off 掉事件
     */
    //- 当 one === 1 的情况
    if( one === 1) {
      origFn = fn;
      fn = function( event ) {
        // event 中包含信息,可以使用空的实例对象
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };

      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );

    }

    // 遍历元素添加绑定事件
    return this.each( function(){
      jQuery.event.add(this, types, fn, data, selector);
    })



  }

  one(): 绑定过最多执行一次的事件监听
    function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
      },

  off(): 统一的移除方法

  tigger(): 手动触发事件监听函数和默认行为

  tiggerHandle(): 手动触发

});



</pre>


      </div>
    </div>



    <div class='row'>
      <div class="col-md-12">
        <div class="progress">
          <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 49.001%;background:#428bca">
            <span style='min-width: 20px;color:#fff'>49.001% 进度 代码共8830行/4318行</span>
          </div>
        </div>
      </div>
    </div>
  </div>


</body>
</html>

